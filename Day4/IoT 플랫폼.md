# IoT 플랫폼, 파이썬 등

## 2. IoT 플랫폼

### (1) IoT 기본 및 IoT 플랫폼

- IoT(Internet of Things)

  → 모든 사물을 인터넷에 연결

  → 사물에 의해서 발생된 Data 수집을 통해 2차적인 정보 활용 가능

- ![1](./img/1.png)

### (2) 쓰레드와 프로세스

- 쓰레드는 직접 구현하거나 상속으로 구현할 수 있다.
  - 직접 구현 `t = threading.Thread(target=loop, args=(i, loops[i]))`
  - 상속 구현 ` class MyThread(threading.Thread):`

- 동시성 처리를 위해서는 일반적으로 파이썬에서 Process를 활용해서 해결한다.
  - Thread도 동시성 처리가 가능은 하지만 주로 process 선호
- 쓰레드 vs 멀티프로세스
  - 멀티프로세스는 각각의 프로세스를 생성하여 사용하고, 쓰레드는 한 프로세스 내에서 자원을 할당받아 사용한다.
  - 즉, 멀티프로세스는 A, B, C라는 프로세스를 생성하여 사용하고, 쓰레드는 A 프로세스에서 A-1, A-2, A-3으로 이루어지게 된다.
  - 이렇기에 어제 1~100까지 따로 더하는 예에서 멀티프로세스는 공유하는 전역 변수가 없기에 사용할 수 없다. 대신, 멀티프로세스는 공유하는 cpu? ram의 자원이 부족할 때 해결하기 위해 lock을 걸게 된다. 쓰레드는 한 프로세스 내에서 공유하는 전역 변수의 값이 엉키지 않게 하기 위해 lock을 걸게 된다.
  - ![6](./img/6.png)



### (3) IPC(Inter-Process Communication)

- Process간 data 공유 목적으로 사용하는 도구

- Queue : FIFO(First In First Out), 단방향, multi thread/process에 대해서 safe
- Pipe : 양방향 통신을 지원, multi process에 대해서 non safe



### (4) TCP/IP 기반 process 

- TCP Server Program

1. Single client 접속(단일 접속 Server)

2. Multi client 접속(다중 접속 Server)

     (1) Multi Processing

     (2) Multi Threading

     (3) Multi Plexing : 별도 Process/Thread를 생성하지 않고, 실제 client의 요청이 있을 때만 처리

\* (1), (2)는 100명의 클라이언트가 들어오면 100개의 process, thread가 만들어져야한다. 이는 과도한 자원 점유가 생성되며 처리에 문제가 생긴다. (이를 악용한 것이 디도스 공격)

\* 이를 해결하는 것이 (3) Multi Plexing이다. 



- 강사님 대표 예시가 multi client 접속(다중 접속 Server)
  - 각 Process를 만들고,  Process를 리스트[]에 담아둬서 p.start 시킨 것.
  - 강사님 예시를 설명해보시오



### (5) 동기, 비동기

https://blog.naver.com/jshjsh06/221251323143

- thread 1, 2, 3이 공유자원을 처리하기 위해 동시에 처리하는 과정에서 동기화 문제가 발생하기 때문이다. 즉 자원을 동시에 사용하려다가 분해되버리는 것이라 생각해도 비슷.

- 예를 들어 sleep(1)이라는 시간동안 Thread1이 Sum += i 의 2번 과정을 진행하는 동안 Thread2가 Sum += i를 진행하면서 Thread1이 완벽하게 진행하지 못한 Sum의 값을 읽어오면서 값이 누락되는 것임!!

- 해결방법 1 : synchronized 사용 -> 처리할 때까지 lock을 건다.

  - ` public synchronized void calc( int start, int stop ) {..}`


​    



### (6) 생산자 및 소비자

조그 프로세스에는 명령어를 queue에 집어 넣고
모터 프로세스에는 queue에 있는 명령어를 실행시킨다.
큐는 파이프에 비해 안정적으로 공유자원을 관리하게 해준다.

★즉, 조그 프로세스는 생산자이고 모터 프로세스는 소비자이다.

★이 개념이 지속적으로 사용되고 있으니 이러한 시각으로(좀 더 넓은 시각으로) 문제에 접근하고 해결하자!!



### (7) 콜링, 인터럽트

- 택배온 것을 확인할 때

  콜링 : 계속 초인종을 누르는지 확인하고 있음

  인터럽트 : 초인종 눌렀을 때 찾아서 봄



### (8) 라즈베리파이 라이브러리 실습 - 서버에서 클라이언트가 전송하는 센서 데이터 값 DB화 ★★ (라즈베리파이, cortex 공부하고 다시 볼 것)

- 이를 설명해보시오

https://blog.naver.com/jshjsh06/221271775188



### (9) appjar = gui



### (10) (IoT 플랫폼 설계 10, 11일차) 웹서버 실습

- ![2](./img/2.png)
- 







## 3. 파이썬 중급

### (1) 컴파일형 언어 인터프리터 언어

- Compile 형 언어

  Interpreter형 언어 ->  Script 언어 - HTML, Python, Java Script(동적 자료형)

- 사람이 한 마디 할 때마다 동시통역해주는 방식을 인터프리트(interpret) 방식이라고 하구요, 사람이 말하는 것을 처음부터 끝까지 듣고 나서 한꺼번에 바꿔주는 것을 컴파일(compile) 방식이라고 하지요.

  우리가 배우는 파이썬은 어떤 방식일까요? 물론 인터프리트 방식이겠죠? 우리의 명령을 한 줄 씩 해석해서 일을 하니까요. 바로 이 '이상한 프로그램'도 파이썬으로 작성된 프로그램을 컴퓨터에게 번역해주는 인터프리터(interpreter)랍니다.

- 컴파일 언어는 컴퓨터의 CPU가 해석하고, 인터프릿 언어는 인터프리팅 프로그램이 해석합니다. 후자가 당연히 느리죠. 프로그램이 프로그램을 해석하니까.



### (2) 컴퓨터 구조, OS

- 알아야할 것(최소한 정의를 할 수 있어야하는 것)

1. Computer 구조
   \- CPU / Memory / Device(I/O)

2. Operating System(OS)

   \- 기본 사용법

   \- O/S 제공 Service 활용 (win32, API, System Call..)



### (3) OOP(Object Oriented Programming)

- object : 현실 세계에 존재하는 모든 실체/개념
  - 속성(Attribute) : 상태
  - 행위(Behavior) : 속성을 변화시키거나 이용하는 동작



​                           ↓↓↓ 



- 추상화(관심을 갖는 내용에 맞게 단순화)
  - Class : 컴퓨터상에 생성할 object에 대한 
  - template(틀)
  - template : 속성 - Field, 행위 - Method



​                           ↓↓↓ 



- 인스턴스화 
  - to Computer World(Memory) + memory(heap)에 생성
  - Instance : Memory에 생성된 object
  - Instance에 Message 전달!



- 클래스 구성 요소
  - Field(member)
  - Method(function)





###   (4) MVC 모델

https://jhc9639.blog.me/220967034588?Redirect=Log&from=postView (이 포스트만 제대로 이해하면 굿)

- 모델, Model

  애플리케이션의 정보, 데이타를 나타냅니다. 데이타베이스, 처음의 정의하는 상수, 초기화값, 변수 등을 뜻합니다. 또한 이러한 DATA, 정보들의 가공을 책임지는 컴포넌트를 말합니다.

  - 1. 사용자가 편집하길 원하는 모든 데이터를 가지고 있어야 한다.
    2. 뷰나 컨트롤러에 대해서 어떤 정보도 알지 말아야 한다.
    3. 변경이 일어나면, 변경 통지에 대한 처리방법을 구현해야만 한다.

- 뷰, View

  input 텍스트, 체크박스 항목 등과 같은 사용자 인터페이스 요소를 나타냅니다. 다시 말해 데이터 및 객체의 입력, 그리고 보여주는 출력을 담당합니다. 웹으로 예를 들면 클라이언트의 화면을 나타내는 html, css, javascript 가 될 수 있겠죠. 

  - 1. 모델이 가지고 있는 정보를 따로 저장해서는 안된다.

    2. 모델이나 컨트롤러와 같이 다른 구성요소들을 몰라야 된다.

    3. 변경이 일어나면 변경통지에 대한 처리방법을 구현해야만 한다.

- 컨트롤러,Controller

  데이터와 사용자인터페이스 요소들을 잇는 다리역할을 합니다. 
  즉, 사용자가 데이터를 클릭하고, 수정하는 것에 대한 "이벤트"들을 처리하는 부분을 뜻합니다. 

  - 1. 모델이나 뷰에 대해서 알고 있어야 한다.
    2. 모델이나 뷰의 변경을 모니터링 해야 한다.

- 명함 : 모델, 명함철 : 컨트롤러, 명함View : view
  - '명함View'에서 사용자의 입력을 받는다. 단순히 데이터만 받아서 넘기는 역할이다
  - 받은 사용자의 입력을 '명함'에게 전달한다.
    - 모델인 '명함'은 모든 데이터의 근원이라고 볼 수 있다. 핵심 데이터인 명함을 정의하고 생성한다.
  - 생성된 명함은 컨트롤러가 가져간다.
    - View에서 받은 데이터로 만들어진 명함은 '명함철'이 가져간다. 즉, 모델과 뷰의 연결고리이다.



## 4. 자바

### (1) 컴퓨터 구조, 프로그램 동작 원리

- ![3](/img/3.png)
- https://blog.naver.com/dudwls251/220604910056 => 잘정리되어있음
- CPU(중앙처리장치)
  - ALU(Arithmetic Logic Unit) : 연산 그 자체를 담당
    - 덧셈, 뺄셈, 산술연산, 논리연산
  - 컨트롤 유닛(Control Unit) : 명령어를 해석(명령어 해석 후 ALU에 보내 연산 처리)
  - CPU 내부 레지스터(Register set) : 연산처리 중 또 다른 연산 요청을 받았을 때, 임시적으로 요청을 저장해놓는 장소
  - 버스 인터페이스 : 다른 장치에서 오는 데이터를 받거나, 보내는 역할
    - I/O  버스 통신을 통해 데이터 수신 전송
    - I/O 버스 : 마이크로프로세서와 입출력 장치 사이에 정보를 전달
  - 클럭신호 : 시스템들을 동기화 시켜주는 역할
    - 느린신호에 맞춰서 입력신호 받음 -> 연산 -> 출력
- I/O(Input/Output) : 입력/출력 장치



### (2) 자바 특징

- ![4](/img/4.png)
- ![5](/img/5.png)

- \- 이식성이 높은 언어이다. 자바 가상머신만 있으면 적용이 가능하다!

  \- 객체 지향 언어이다. 라이브러리 형태가 class이다.

  \- 함수적 스타일 코딩을 지원한다.

  \- 메모리를 자동으로 관리한다. 

  \- 다양한 어플리케이션을 개발할 수 있다.

  \- 멀티스레드를 쉽게 구현할 수 있다.

  ​    a. Process : 실행 中인 Program

  ​    b. Thread : Process 內의 실행 흐름. O/S가 제공

  \- 동적 로딩을 지원한다.

  \- 막강한 오픈소스 라이브러리가 풍부하다.



### (3) 배열과 클래스

https://blog.naver.com/jshjsh06/221245901141



### (4) 클래스 MVC 모델

https://blog.naver.com/jshjsh06/221248414466



### (5) 인터페이스와 상속의 차이

http://ryulib.tistory.com/316

> \#추상클래스 : 추상 메소드가 하나 또는 그 이상 포함된 클래스
>
> \#인터페이스 : 인터페이스 내의 모든 메소드들은 빈 껍데기만 있는 메소드

추상클래스

추상 클래스는 **추상 메소드를 하나 이상** 갖고 있는 클래스를 말한다. **#추상메소드**는 abstract 키워드를 사용하여 정의하며, 그 내부의 내용은 정의되어 있지 않다. 만약 추상메소드를 하나라도 포함하고 있는 추상 클래스라면, 이 클래스 역시 abstract 키워드를 사용하여 표시해 주어야 한다. 추상클래스 내에는 추상메소드 뿐만 아니라 일반 메소드도 가질 수 있으며, 일반 멤버변수 또한 가질 수 있다.



인터페이스

인터페이스는 내용이 없는 메소드들의 형태만 구현해놓은 **추상메소드의 집합**이라고 할 수 있다. 인터페이스는 일반 메소드나 일반 변수를 가질 수 없으며 변수의 형태는 static만 가능하다. 그리고 클래스와 가장 큰 차이점이 바로 생성자를 가질 수 없다는 것이다.



추상클래스와 인터페이스의 사용

이 둘의 가장 큰 차이점은 자바의 중요한 **#상속** 개념에서 나타난다. 자바에서는 **다중 상속**이 허용되지 않는다. 그 이유는 일반 클래스가 추상클래스를 상속받았을 경우, 슈퍼클래스의 모든 추상메소드를 새롭게 정의해야 하는데, 만약 두개 이상의 슈퍼클래스에서 같은 이름의 추상메소드를 가지고 있다면 어떤 메소드를 실행해야 할지 모호해지기 때문이다. 반면에 인터페이스는 한번에 여러개를 상속받을(구현할) 수 있다.

그 외에도 다양한 형태적, 용법적 차이를 가진다.
* 클래스 상속에는 extends 키워드를 사용하며, 인터페이스 구현에는 implements 키워드를 사용한다.
* 인터페이스 간의 상속에서는 extends를 사용한다.
* 클래스 다중상속은 지원하지 않지만 인터페이스는 동시에 여러개를 구현할 수 있으며, 클래스 상속과 동시에 인터페이스 구현도 가능하다.
* 일반 클래스가 추상클래스를 상속받을 경우, 모든 추상메소드를 반드시 구현해야만 하지만 추상클래스가 추상클래스를 상속받은 경우에는 반드시 모든 추상메소드를 구현해야 하는 것은 아니다.
* 인터페이스를 구현할 경우 반드시 모든 메소드를 정의해야 한다.

**[출처]** [[Java\] 추상 클래스와 인터페이스의 차이점](https://blog.naver.com/tngusmiso/221367243486)|**작성자** [슈프림](https://blog.naver.com/tngusmiso)



### (6) 정적 멤버와  static
- 정적(static)은 '고정된'이란 의미를 가지고 있다. 정적 멤버는 클래스에 고정된 멤버로서 객체를 생성하지 않고 사- 용할 수 있는 필드와 메소드를 말한다. 정적 멤버는 객체(인스턴스)에 소속된 멤버가 아니라 클래스에 소속된 멤버이기 때문에 클래스 멤버라고도 한다.- 필드를 선언할 때 인스턴스 필드로 선언할 것인가, 아니면 정적 필드로 선언할 것인가의 판단 기준은 객체마다 가지고 있어야 할 데이터라면 인스턴스 필드로 선언하고, 객체마다 가지고 있을 필요성이 없는 공용적인 데이터라면 정적 필드로 선언하는 것이 좋다. (ex. Calculator 클래스에서 원의 넓이나 둘레를 구할 때 필요한 파이는 정적 필드로 선언하는 것이 좋다.)- 메소드의 경우, 인스턴스 메소드로 선언할 것인가, 아니면 정적 메소드로 선언할 것인가의 판단 기준은 인스턴스 필드를 이용해서 실행해야 한다면 인스턴스 메소드로 선언하고, 인스턴스 필드를 이용하지 않는다면 정적 메소드로 선언한다.- 클래스가 메모리로 로딩되면 바로 정적 멤버를 사용할 수 있다. Calculator.Pi, Calculator.Plus()- 이들은 객체가 없어도 실행된다는 특징 때문에, 이들 내부에 인스턴스 필드나 인스턴스 메소드를 사용할 수 없다. 또한 this 키워드도 사용할 수 없다.
- 인스턴스 메소드 호출 시 : 클래스형 변수 이름.메소드 이름
- 클래스 메소드(static) 호출 시 : 클래스 이름.메소드 이름



### (7)  final 필드와 상수

#### 1) final
- final의 의미는 최종적이란 뜻을 가지고 있다. 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없다는 것이다.- 보통 필드 선언 시에 final을 생성한다. 또는 생성자에서 생성한다.


#### 2) 상수(static final)
- 일반적으로 불변의 값을 상수라고 부른다. 원주율의 파이, 지구의 무게 및 둘레 등을 말한다.- final 필드는 객체마다 저장되고, 생성자의 매개값을 통해서 여러가지 값을 가질 수 있기 때문에 상수가 될 수 없다.- 상수는 객체마다 저장할 필요가 없는 공용성을 띈다.- static final 필드는 객체마다 저장되지 않고, 클래스에만 포함된다. 그리고 한 번 초기값이 저장되면 변경할 수 없다.- `static final double PI = 3.14159;`, `static final double EARTH_SURFACE_AREA;`



### (8) 접근 제한자

- public, protected, default, private 네 가지 종류가 있다.  - public : 외부 클래스가 자유롭게 사용할 수 있는 공개 멤버  - protected : 같은 패키지 또는 자식 클래스에서 사용할 수 있는 멤버  - private : 외부에 노출되지 않는다.  - default : 같은 패키지에 소속된 클래스에서만 사용할 수 있는 멤버- public < protected < default < private 순으로 접근 제한이 강화된다.- 클래스는 public 또는 default 단 두가지만 제한할 수 있다.  - default : class 클래스 { ... }  - public : public class 클래스 { ... }



### (9) 추상 클래스와 인터페이스

#### 1) 추상클래스
- 실체 간에 공통되는 특성을 추출한 것  - 새, 곤충, 물고기의 공통 특성은 동물  - LG, 현대, SK, 삼성의 공통 특성은 회사- 객체를 직접 생성할 수 있는 클래스를 실체 클래스라고 한다면 이 클래스들의 공통적인 특성을 추출해서 선언한 클래스를 추상 클랫흐라고 한다.- 추상 클래스는 실체 클래스의 공통되는 필드와 메소드를 추출해서 만들었기 때문에 객체를 직접 생성해서 사용할 수 없다.  즉, new 연산자를 사용해서 인스턴스를 생성시키지 못한다.


#### 2) 인터페이스
- 다형성을 구현하는 매우 중요한 역할- 개발 코드를 수정하지 않고, 사용하는 객체를 변경할 수 있도록 하기 위해 사용- 인터페이스는 데이터를 저장할 수 없기 때문에 데이터를 저장할 인스턴스 또는 정적 필드를 선언할 수 없다. 대신 상수 필드만 선언할 수 있다. public static final



## 5. 라즈베리파이

### (1) GPIO - General Purpose Input and Output

- 범용 입/출력 장치를 지칭하는 용어
- IC PIN은 208개이고 내장된 기능이 약 600개
- GPIO는 IC에 내장된 기능과 입/출력 동작을 설정하고, 가 ㄱ동작의 세부 상태를 설정하는 용도
- AP의 물리적인 특정 핀(AP의 물리적인 형태를 가지는 IC 실제 핀 하나에 대해)의 동작 상태를 입력 또는 출력으로 설정
- BCM은 라즈베리파이의 CPU라고 생각해도 된다. BCM 연결 포트(선)은 우리가 설정할 수도 있지만 미리 설정해둔 상태임
  - BCM은 단순히 1 또는 0의 신호만 주는 역할을 하는 것임.



#### 1) GPIO LED

- BCM은 14, 15번. 
- 전압과 전류는 높은 곳에서 낮은 곳으로 가는 것이 기본.
- `import RPi.GPIO as GPIO`
  - 라즈비안 OS에 기본 포함된 GPIO 라이브러리
- `impot time`
  - 시간 지연 함수 라이브러리
  - time.sleep(1)
- `GPIO.setmode(GPIO.BCM)`
  - 확장 커넥터의 핀 번호 할당 방식을 지정
- LED GPIO 핀 번호 지정
  - led_pin1 = 14
  - led_pin2 = 15
- `GPIO.setup(led_pin1, GPIO.OUT)`
  - led_pin1의 번호인 14번 핀을 출력으로 설정!
- LED 1의 GPIO를 on/off로 설정
  - GPIO.output(led_pin1, False)
  - GPIO.output(led_pin2, True)



#### 2) GPIO Motor

- GPIO_RP : 정회전, GPIO_RN : 역회전, GPIO_EN : 작동 ON/OFF



#### 3) 상승에지, 하강에지 개념 + 슈미트 트리거

- 버튼을 누르는 순간 또는 값이 1, 0으로 바뀌는 그 짧은 순간에 1과 0사이의 신호가 수십번 나올 수 있다. 이러한 문제를 해결하기 위해 에지체크를 한다.
- 버튼을 누르는 순간 0이 1로 되는 첫 시점은 하나밖에 없음 => 이를 상승에지라고 한다.
- 버튼을 누르는 순간 1이 0으로 되는 첫 시점은 하나밖에 없음 => 하강에지
- 0V 구간과 5V 구간 사이의 애매한 중간 값은 0 또는 1로 설정하기에 애매하다. 이러한 중간값을 잡음없이 깔끔하게 만드는 것을 '슈미트 트리거' 라고 한다.



#### 4) GPIO JOG

- GPIO.setup(GPIO[5], GPIO.IN)
  - 조그에 해당하는 5번 핀을 입력으로 설정!
- `cur_stat = GPIO.input(gpio[5])`
  - 5번 핀의 현재 값을 ㅇ릭어 cur_stat에 저장함. (while 문 내에 위치)



#### 5) GPIO Character LCD

- 1~16번 포트를 이용
- LCD는 전송 받은 각 명령을 실행하기 위해 일정 시간 요구
- 제어 신호 및 제어 명령 조합으로 많은 설정이 필요과 동작 기능 있음
  - 읽기/쓰기모드
  - clear display
  - 커서 home으로 이동
  - 화면 이동
  - 커서 깜박임 또는 화면 표시 설정
  - 8비트, 4비트 지정
  - 화면 표시 행수 1, 2행 조절
  - 등등



#### 6) Ultrasonic Sensor

- TRIG핀에 최소 10마이크로 초 동안 HIGH 신호를 전달하면 송신기는 40khz 초음파 8개를 방사한 후 반사되어 돌아오는 것을 기다리고 체크



#### 7) IR Receiver(적외선 수신기) 리모콘



#### 8) PIR Sensor(적외선 파장의 움직임에 반응하는 센서)



### (2) I2C(Inter-IC Communication)

- I2C는 필립스에서 제안한 통신 방식
  - 두 개의 신호를 사양하는 양방향 직렬 통신 방식
  - 하나의 Master와 다수의 Slave로 구성
  - 반드시 pull-up 저항 필요



#### 1) 풀업 풀다운

https://kocoafab.cc/tutorial/view/526

- 일반적인 연결로는 입출력핀에 아무런 신호가 가지 않을 경우 0도 아니고 1도 아닌 플로팅 상태를 가지기 때문에 이 문제를 해결해 주어야 합니다. 이 문제를 해결하는 방법이 바로 풀업, 풀다운입니다.
- **풀업(PULL-UP)이라는 말의 의미는 플로팅 상태일때의 값을 끌어올린다는 의미**입니다. 당연히 플로팅 상태의 값을 올리기 때문에 스위치가 열려있을때의 상태는 플로팅 상태가 아닌 값이 1이 되겠죠?
- 저항을 VCC단자에 달아주는것이 중요합니다. (풀다운의 경우에는 반대로 VCC가 아닌 GND쪽에 저항을 달아줍니다.) 저항하나를 달아줌으로 플로팅상태를 방지할 수 있습니다.



#### 2) LIGHT / TEMP / HUMI / FND

- 조도, 온도, 습도, FND 모두 I2C 통신을 통해 구현된다. 



### (3) SPI

- 완전 전이중 통신
- 동기화 직렬 데이터 연결

#### 1) EEPROM, MPU3208(가변저항)

- SPI를 통해 구현된다.



## 6. Cortex-M4

- Cortex-M 프로세서는 미리 정의된 메모리 맵을 사용한다.
  - 32bit의 최대 크기인 4GB의 공간을 미리 할당해서 고정된 메모리맵을 사용하여 고정된 주소를 사용하게 된다.

### (1) RCC(Reset and Clock Control), GPIO

- ★★ RCC, GPIO 모두 자신의 '레지스터 주소값'을 가진다.
  - RCC_AHB1ENR의 레지스터 주소는 0x4002 3830이다.
    - 이는 C언어에서 `#define RCC_AHB1ENR (*(volatile unsigned long *)0x40023830)` 으로 정의된다.
    - volatile은 컴파일할 때 컴퓨터는 최적화를 위해 필요없는 구문을 삭제한다. 이를 방지하는 것이 volatile이다. 최적화 하지 않고 기계어 그대로 번역
  - 0x4002 3830은 16진수로 8자리로 이루어져있다. 이는 2진수로 32자리를 의미한다.
    - 4002 383'0' 의 '0'은 2진수로 0b0000~0b1111 범위를 가진다.
    - 즉, 총 32자리에 각각의 기능이 담겨있다. 이 32개 자리에 0 또는 1을 넣음으로써 기능을 활성화한다.
    - 예로, `RCC_AHB1ENR = 0x00000004;`를 실행한다는 것은 RCC 레지스터 주소에 16진수의 4(2진수의 0100)를 넣는다는 의미이다.
      - RCC_AHBIENR에 0100은 GPIOCEN(GPIOC 포트를 Enable)한다는 의미이다.
      - ★ 그런데 0x4002 3830인 레지스터 주소 값에 0x0000 0004를 넣는다는 것은 레지스터 주소값이 바뀌는 것 아닐까?
  - LD1을 키고 싶다면 핀맵을 봐야한다. PC2는 GPIOC의 MODER2를 의미한다. LD1을 작동하려면 0x4002 0800 GPIOC 레지스트리 주소에 0x0000 0010을 넣어야한다.
    - GPIOC_ODR의 역할?

#### 1) RCC

- RCC : Reset과 Clock을 관장하는 장치
  - 리셋
    - STM32F4 시리즈의 리셋은 시스템 리셋, 전원 리셋, 백업 영역 리셋의 3가지가 있다.

  - 클락
    - System Clock와 Secondary Clock으로 구분
- RCC는 보드에 전원을 넣어주는 역할이라고 생각하면되고, GPIO는 기능을 사용하는 역할이라고 생각



#### 2) GPIO

- 마이크로프로세서가 주변 장치와 통신하기 위해 범용으로 사용되는 입출력 포트



### (2) HAL

- 하드웨어 추상화 계층(HAL, Hardware Abstraction Layer)은 컴퓨터 물리적인 컴퓨터에서 실행되는 소프트웨어 사이의 계층이다. 이것은 하드웨어의 차이를 숨겨서 응용 프로그램이 작동할 수 있는 일관된 플랫폼을 제공한다.
- 일일히 volatile로 주소 지정하고 GPIOC enable 시키고 했던 것들을 간단히 함수로 바로 사용할 수 있게 함. 하나의 라이브러리라고 생각하면 됨.
- ![7](/img/7.png)



### (3) 익셉션과 nvic, 인터럽트, 폴링

- 익셉션과 인터럽트는 하나의 예외, 우선적으로 사용되는 특정 명령이라고 생각하면 된다.
  - 1~15번은 시스템 익셉션으로 구성되어있다.
    - reset, 모든 구성 fault로 전환 등 강한 명령을 가지고 있다.
  - 16~255번은 외부인터럽트로 구성되어 있다. 외부 인터럽트는 우선순위를 우리가 설정할 수 있다.

- nvic은 중첩된 인터럽트를 제어하는 기능. 모든 Exception에 대해 우선순위가 정해져있고, 이 순위에 따라 인터럽트를 처리할 수 있도록 도와주는 controller이다.



### (4) Interrupt와 Polling 방식 차이

- 둘다 어떠한 이벤트에 컴퓨터가 반응하는 방식이다.
- polling 방식은 어떤 이벤트가 발생할 때까지 계속 확인하는 방식이다.
  - 예를 들어 택배가 올 때까지 계속 초인종을 확인하고 밖을 확인하는 방식
  - 시간과 자원을 지속적으로 소비한다.
- Interrupt 방식은 어떤 이벤트가 발생하면 하던 일을 멈추고 확인하는 방식이다.
  - 예를 들어 평소 우리가 하던 일을 하다가 초인종이 울리면 택배를 받는 방식
  - 하던 일은 Stack Point에 저장하고, Interrupt Service를 처리한 후, 저장했던 stack point로 되돌아와 일을 진행한다.



### (5) 외부인터럽트

- 내/외부 신호를 감지하여 event, interrupt, wakeup 요청을 발생시키는 장치
- 1. GPIO 모듈을 열어둔다.
  2. SYSCFG 모듈, 즉 사용하고자하는 외부 인터럽트를 열어둔다.
  3. EXTI모듈에서 인터럽트를 하강에지 또는 상승에지일 때 인터럽트로 할지 설정한다.
  4. NVIC 모듈로 우선순위를 설정해준다.
  5. EXTI_PR 모듈을 통해 인터럽트를 발생했는지 확인 플래그를 설정해준다. 이를 통해 인터럽트가 처리되었는지 확인하는 것.



### (6) 타이머

- 일정시간마다 Event 또는 Interrupt 발생
- 외부에서 입력되는 Pulse 길이 측정
- 일정한 길이의 Pulse 출력
- 필요성
  - CPU의 부담없이 시간 경과를 알 필요가 있다.
    - 하드웨어적으로 이루어지므로 CPU 부담 감소
  - CPU 부담 없이 장치 제어를 위한 주기적은 펄스 출력이 필요하다.
  - 외부에서 입력되는 펄스의 정확한 발생 시각을 알 필요가 있다.
- 타이머를 설정하고 타이머 시간에 발생되는 함수를 지정한다. 해당 타이머 시간이 경과되면 해당 함수가 주기적으로 발생한다.
  - LED ON / OFF를 주기적인 시간으로 사용된다.



## 7. 멋사

### (1) 잡다

-  JavaScript

  - HTML, CSS는 프로그래밍 언어가 아니고, JavaScript는 프로그래밍 언어이다.

  - 대중적으로 아는 것은 움직임을 표현해줌.

- cli => 터미널

  - git 관리할 수 있고, 암튼 터미널

- RubyonRails 구축

  - c9에서 함.

-  Ruby on Rails

  - MVC 디자인(패턴) : 엄청나게 많은 시도들을 해보고 나서 최적의 경로를 공유. 

  M(Model) : 데이터를 관리

  V(View) : 사용자가 보는 화면

  C(Controller) : 중간관리자

  - 동작 원리

    클라이언트가 웹페이지 요청 -> Controller가 Model에게 찾아죠! 요청 -> Model이 DataBase에서 자료를 뒤적뒤적 찾음 -> DataBase가 찾아서 Model에게 줌 -> Model이 Controller에게 전해줌 -> Controller가 View에게 해당 자료를 보내줌 -> View가 정갈하게 정리해서 클라이언트에게 전달

- CRUD(Create, Retrieve, Update, Destroy)

  - https://blog.naver.com/jshjsh06/221302739289 

  - controller
    - new, create, show, index, edit, update, destroy